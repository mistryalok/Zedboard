// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2014.4
// Copyright (C) 2014 Xilinx Inc. All rights reserved.
// 
// ==============================================================

#ifndef AESL_axi_s_counter_HH_
#define AESL_axi_s_counter_HH_

#include <systemc>
#include <vector>
using std::vector;
using namespace std;
SC_MODULE(AESL_axi_s_counter) {
    sc_core::sc_in_clk clk;
    sc_core::sc_in< sc_dt::sc_logic > reset;
    sc_core::sc_in<sc_dt::sc_lv<32>  > TRAN_counter_TDATA;
    sc_core::sc_in<sc_dt::sc_logic > TRAN_counter_TVALID;
    sc_core::sc_out<sc_dt::sc_logic > TRAN_counter_TREADY;
    sc_core::sc_in< sc_dt::sc_logic > counter_TDATA_debug;
    sc_core::sc_in< sc_dt::sc_logic > ready;
    sc_core::sc_in< sc_dt::sc_logic > done;
    std::vector<sc_dt::sc_lv<32> > counter_TDATA_mStorage;
    sc_core::sc_signal< sc_dt::sc_uint<1> > counter_TDATA_mInPtr;
    sc_core::sc_signal< sc_dt::sc_uint<1> > counter_TDATA_mOutPtr;
    sc_core::sc_signal< sc_dt::sc_uint<1> > counter_TDATA_debug_in_ptr;
    sc_core::sc_signal< sc_dt::sc_uint<1> > counter_TDATA_debug_out_ptr;
    sc_core::sc_signal< sc_dt::sc_logic > counter_TDATA_debug_nEF_hint;
    sc_core::sc_signal< sc_dt::sc_logic > counter_TDATA_mFlag_nEF_hint;
    sc_core::sc_signal< sc_dt::sc_logic > counter_TDATA_empty_n;
    sc_core::sc_signal< sc_dt::sc_logic > counter_TDATA_full_n;
    sc_core::sc_trace_file* mTrace;

    SC_CTOR(AESL_axi_s_counter) : mTrace(0) {
        const char* dump_vcd = std::getenv("AP_WRITE_VCD");
        if (dump_vcd && string(dump_vcd) == "1") {
        std::string tracefn = "sc_trace_" + std::string(name());
        mTrace = sc_core::sc_create_vcd_trace_file(tracefn.c_str());
        sc_trace(mTrace, clk, "(port)clk");
        sc_trace(mTrace, reset, "(port)reset");
        sc_trace(mTrace, TRAN_counter_TDATA, "(port)counter_TDATA");
        sc_trace(mTrace, counter_TDATA_mInPtr, "(port)counter_TDATA_mInPtr");
        sc_trace(mTrace, counter_TDATA_mOutPtr, "(port)counter_TDATA_mOutPtr");
        sc_trace(mTrace, counter_TDATA_full_n, "(port)counter_TDATA_full_n");
        sc_trace(mTrace, counter_TDATA_empty_n, "(port)counter_TDATA_empty_n");
        sc_trace(mTrace, counter_TDATA_mFlag_nEF_hint, "(port)counter_TDATA_mFlag_nEF_hint");
        sc_trace(mTrace, TRAN_counter_TVALID, "(port)counter_TVALID");
        sc_trace(mTrace, TRAN_counter_TREADY, "(port)counter_TREADY");
        sc_trace(mTrace, ready, "(port)ready");
        sc_trace(mTrace, done, "(port)done");
        }

        SC_METHOD(proc_counter_TDATA_read_write);
        sensitive << clk.pos() << counter_TDATA_debug.pos();

        SC_METHOD(proc_counter_TDATA_ptr);
        sensitive << counter_TDATA_mInPtr << counter_TDATA_mOutPtr << counter_TDATA_mFlag_nEF_hint;
        
        SC_METHOD(proc_counter_TREADY);
        sensitive  << counter_TDATA_full_n<< reset;
        
    }
    ~AESL_axi_s_counter() {
        if (mTrace) sc_core::sc_close_vcd_trace_file(mTrace);
    }

    void proc_counter_TREADY() {
        if (reset.read() == sc_dt::SC_LOGIC_0) {
            TRAN_counter_TREADY = sc_dt::SC_LOGIC_0;
        } else {
            TRAN_counter_TREADY = sc_dt::SC_LOGIC_1;
        }
    }
//============================ counter_TDATA ==========================
    void proc_counter_TDATA_read_write() {
        if (reset.read() == sc_dt::SC_LOGIC_0) {
            counter_TDATA_mInPtr.write(0);
            counter_TDATA_mOutPtr.write(0);
            counter_TDATA_mFlag_nEF_hint.write(sc_dt::SC_LOGIC_0);
        }
        else if (counter_TDATA_debug.read() == sc_dt::SC_LOGIC_1) {
            counter_TDATA_mInPtr.write(counter_TDATA_debug_in_ptr);
            counter_TDATA_mOutPtr.write(counter_TDATA_debug_out_ptr);
            counter_TDATA_mFlag_nEF_hint.write(counter_TDATA_debug_nEF_hint);
        }
        else {
            if (TRAN_counter_TVALID.read() == sc_dt::SC_LOGIC_1 
                && counter_TDATA_full_n.read() == sc_dt::SC_LOGIC_1) {
                sc_dt::sc_uint<1> ptr;
                ptr = counter_TDATA_mInPtr.read();
                if (ptr.to_uint() >= counter_TDATA_mStorage.size()) {
                    counter_TDATA_mStorage.push_back(TRAN_counter_TDATA.read());
                }
                else {
                    counter_TDATA_mStorage[ptr.to_uint()] = TRAN_counter_TDATA.read();
                }
                ptr++;
                counter_TDATA_mInPtr.write(ptr);
            }
        }
    }

    void proc_counter_TDATA_ptr() {
        if (counter_TDATA_mInPtr.read() == counter_TDATA_mOutPtr.read() && counter_TDATA_mFlag_nEF_hint.read()==sc_dt::SC_LOGIC_1) {
            counter_TDATA_full_n.write(sc_dt::SC_LOGIC_0);
        }
        else {
            counter_TDATA_full_n.write(sc_dt::SC_LOGIC_1);
        }
    }
};

#endif //AESL_axi_s_counter_HH_
