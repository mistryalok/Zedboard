// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2014.4
// Copyright (C) 2014 Xilinx Inc. All rights reserved.
// 
// ==============================================================

#ifndef AESL_axi_s_count_range_HH_
#define AESL_axi_s_count_range_HH_

#include <systemc>
#include <vector>
using std::vector;
using namespace std;
SC_MODULE(AESL_axi_s_count_range) {
    sc_core::sc_in_clk clk;
    sc_core::sc_in< sc_dt::sc_logic > reset;
    sc_core::sc_out<sc_dt::sc_lv<32>  > TRAN_count_range_TDATA;
    sc_core::sc_out<sc_dt::sc_logic > TRAN_count_range_TVALID;
    sc_core::sc_in<sc_dt::sc_logic > TRAN_count_range_TREADY;
    sc_core::sc_in< sc_dt::sc_logic > count_range_TDATA_debug;
    sc_core::sc_in< sc_dt::sc_logic > ready;
    sc_core::sc_in< sc_dt::sc_logic > done;
    std::vector<sc_dt::sc_lv<32> > count_range_TDATA_mStorage;
    sc_core::sc_signal< sc_dt::sc_uint<1> > count_range_TDATA_mInPtr;
    sc_core::sc_signal< sc_dt::sc_uint<1> > count_range_TDATA_mOutPtr;
    sc_core::sc_signal< sc_dt::sc_uint<1> > count_range_TDATA_debug_in_ptr;
    sc_core::sc_signal< sc_dt::sc_uint<1> > count_range_TDATA_debug_out_ptr;
    sc_core::sc_signal< sc_dt::sc_logic > count_range_TDATA_debug_nEF_hint;
    sc_core::sc_signal< sc_dt::sc_logic > count_range_TDATA_mFlag_nEF_hint;
    sc_core::sc_signal< sc_dt::sc_logic > count_range_TDATA_empty_n;
    sc_core::sc_signal< sc_dt::sc_logic > count_range_TDATA_full_n;
    sc_core::sc_trace_file* mTrace;

    SC_CTOR(AESL_axi_s_count_range) : mTrace(0) {
        const char* dump_vcd = std::getenv("AP_WRITE_VCD");
        if (dump_vcd && string(dump_vcd) == "1") {
        std::string tracefn = "sc_trace_" + std::string(name());
        mTrace = sc_core::sc_create_vcd_trace_file(tracefn.c_str());
        sc_trace(mTrace, clk, "(port)clk");
        sc_trace(mTrace, reset, "(port)reset");
        sc_trace(mTrace, TRAN_count_range_TDATA, "(port)count_range_TDATA");
        sc_trace(mTrace, count_range_TDATA_mInPtr, "(port)count_range_TDATA_mInPtr");
        sc_trace(mTrace, count_range_TDATA_mOutPtr, "(port)count_range_TDATA_mOutPtr");
        sc_trace(mTrace, count_range_TDATA_full_n, "(port)count_range_TDATA_full_n");
        sc_trace(mTrace, count_range_TDATA_empty_n, "(port)count_range_TDATA_empty_n");
        sc_trace(mTrace, count_range_TDATA_mFlag_nEF_hint, "(port)count_range_TDATA_mFlag_nEF_hint");
        sc_trace(mTrace, TRAN_count_range_TVALID, "(port)count_range_TVALID");
        sc_trace(mTrace, TRAN_count_range_TREADY, "(port)count_range_TREADY");
        sc_trace(mTrace, ready, "(port)ready");
        sc_trace(mTrace, done, "(port)done");
        }

        SC_METHOD(proc_count_range_TDATA_read_write);
        sensitive << clk.pos() << count_range_TDATA_debug.pos();

        SC_METHOD(proc_count_range_TDATA_dout);
        sensitive << count_range_TDATA_mInPtr << count_range_TDATA_mOutPtr;

        SC_METHOD(proc_count_range_TDATA_ptr);
        sensitive << count_range_TDATA_mInPtr << count_range_TDATA_mOutPtr << count_range_TDATA_mFlag_nEF_hint;
        
        SC_METHOD(proc_count_range_TVALID);
        sensitive  << count_range_TDATA_empty_n<< reset;
        
    }
    ~AESL_axi_s_count_range() {
        if (mTrace) sc_core::sc_close_vcd_trace_file(mTrace);
    }

    void proc_count_range_TVALID() {
        if (reset.read() == sc_dt::SC_LOGIC_0) {
            TRAN_count_range_TVALID = sc_dt::SC_LOGIC_0;
        } else {
            TRAN_count_range_TVALID = sc_dt::SC_LOGIC_1 & count_range_TDATA_empty_n;
        }
    }
//============================ count_range_TDATA ==========================
    void proc_count_range_TDATA_read_write() {
        if (reset.read() == sc_dt::SC_LOGIC_0) {
            count_range_TDATA_mInPtr.write(0);
            count_range_TDATA_mOutPtr.write(0);
            count_range_TDATA_mFlag_nEF_hint.write(sc_dt::SC_LOGIC_0);
        }
        else if (count_range_TDATA_debug.read() == sc_dt::SC_LOGIC_1) {
            count_range_TDATA_mInPtr.write(count_range_TDATA_debug_in_ptr);
            count_range_TDATA_mOutPtr.write(count_range_TDATA_debug_out_ptr);
            count_range_TDATA_mFlag_nEF_hint.write(count_range_TDATA_debug_nEF_hint);
        }
        else {
            if (TRAN_count_range_TREADY.read() == sc_dt::SC_LOGIC_1
               && count_range_TDATA_empty_n.read() == sc_dt::SC_LOGIC_1) {
                sc_dt::sc_uint<1> ptr;
                ptr = count_range_TDATA_mOutPtr.read();
                ptr++;
                count_range_TDATA_mOutPtr.write(ptr);
            }
        }
    }

    void proc_count_range_TDATA_dout() {
        sc_dt::sc_uint<1> ptr = count_range_TDATA_mOutPtr.read();
        if (ptr.to_uint() >= count_range_TDATA_mStorage.size() ) {
            TRAN_count_range_TDATA.write(sc_dt::sc_lv<32>());
        } 
        else {
            TRAN_count_range_TDATA.write(count_range_TDATA_mStorage[ptr.to_uint()]);
        }
    }


    void proc_count_range_TDATA_ptr() {
        if (count_range_TDATA_mInPtr.read() == count_range_TDATA_mOutPtr.read() && count_range_TDATA_mFlag_nEF_hint.read()==sc_dt::SC_LOGIC_0) {
            count_range_TDATA_empty_n.write(sc_dt::SC_LOGIC_0);
        }
        else {
            count_range_TDATA_empty_n.write(sc_dt::SC_LOGIC_1);
        }
    }
};

#endif //AESL_axi_s_count_range_HH_
